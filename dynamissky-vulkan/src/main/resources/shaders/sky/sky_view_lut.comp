#version 450
layout(local_size_x=16, local_size_y=8) in;

layout(set=0, binding=0, rgba16f) uniform image2D skyViewLut;
layout(set=0, binding=1) uniform sampler2D transmittanceLut;
layout(set=0, binding=2) uniform sampler2D multiScatteringLut;
layout(set=0, binding=3, std140) uniform SkyViewUBO {
    vec3 sunDirection;
    float sunIntensity;
    vec3 rayleighScatter;
    float mieAnisotropy;
    float planetRadius;
    float atmosphereHeight;
    float pad0;
    float pad1;
} params;

vec3 directionFromUv(vec2 uv) {
    float phi = uv.x * 6.2831853;
    float theta = uv.y * 3.1415926;
    return vec3(
        sin(theta) * cos(phi),
        cos(theta),
        sin(theta) * sin(phi)
    );
}

void main() {
    ivec2 coord = ivec2(gl_GlobalInvocationID.xy);
    ivec2 size = imageSize(skyViewLut);
    if (coord.x >= size.x || coord.y >= size.y) {
        return;
    }

    vec2 uv = (vec2(coord) + 0.5) / vec2(size);
    vec3 viewDir = normalize(directionFromUv(uv));

    vec3 accum = vec3(0.0);
    const int STEPS = 40;
    for (int i = 0; i < STEPS; ++i) {
        float t = (float(i) + 0.5) / float(STEPS);
        vec2 lutUv = vec2(t, clamp(0.5 + 0.5 * viewDir.y, 0.0, 1.0));
        vec3 trans = texture(transmittanceLut, lutUv).rgb;
        vec3 multi = texture(multiScatteringLut, vec2(t, uv.y)).rgb;
        float phase = 0.5 + 0.5 * dot(viewDir, normalize(params.sunDirection));
        accum += trans * params.rayleighScatter * phase + multi * (0.2 + 0.8 * phase);
    }

    vec3 color = accum * (params.sunIntensity / float(STEPS));
    imageStore(skyViewLut, coord, vec4(max(color, vec3(0.0)), 1.0));
}
